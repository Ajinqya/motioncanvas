{
  "id": "glowing-exponential",
  "name": "Glowing Exponential",
  "createdAt": "2026-02-08",
  "updatedAt": "2026-02-08T08:12:45.985Z",
  "source": "ai-chat",
  "prompt": "[EXISTING ANIMATION: glowing-exponential]\nimport type { AnimationDefinition } from '../../runtime/types';\nimport { number, color, boolean, folder } from '../../runtime/params';\n\n/**\n * Glowing Green Exponential Curve\n * Draws an exponential curve that sweeps in from left to right\n * with a vivid neon glow effect on a dark background.\n */\n\ninterface GlowingExponentialParams {\n  // Layout\n  scale: number;\n  curveExponent: number;\n  curveAmplitude: number;\n  lineWidth: number;\n\n  // Colors\n  backgroundColor: string;\n  primaryColor: string;\n  glowColor: string;\n\n  // Glow\n  glowIntensity: number;\n  glowLayers: number;\n  showParticles: boolean;\n\n  // Animation\n  speed: number;\n  trailLength: number;\n}\n\n// Easing helpers\nconst easeInOutCubic = (t: number) =>\n  t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;\n\nconst easeOutExpo = (t: number) =>\n  t === 1 ? 1 : 1 - Math.pow(2, -10 * t);\n\nconst animation: AnimationDefinition<GlowingExponentialParams> = {\n  id: 'glowing-exponential',\n  name: 'Glowing Exponential',\n  fps: 60,\n  durationMs: 4000,\n  width: 1280,\n  height: 720,\n  background: '#050510',\n\n  params: {\n    defaults: {\n      scale: 2.1,\n      curveExponent: 3.5,\n      curveAmplitude: 1.5,\n      lineWidth: 2,\n      backgroundColor: '#050510',\n      primaryColor: '#7a4c33',\n      glowColor: '#ff6600',\n      glowIntensity: 5,\n      glowLayers: 1,\n      showParticles: false,\n      speed: 0.7,\n      trailLength: 0.15,\n    },\n    schema: {\n      ...folder('Layout', {\n        scale: number({ value: 1, min: 0.1, max: 3, step: 0.1, label: 'Scale' }),\n        curveExponent: number({ value: 3, min: 1.5, max: 6, step: 0.1, label: 'Exponent' }),\n        curveAmplitude: number({ value: 0.85, min: 0.2, max: 1.5, step: 0.05, label: 'Amplitude' }),\n        lineWidth: number({ value: 3, min: 1, max: 8, step: 0.5, label: 'Line Width' }),\n      }),\n      ...folder('Colors', {\n        primaryColor: color({ value: '#00ff88', label: 'Curve Color' }),\n        glowColor: color({ value: '#00ff88', label: 'Glow Color' }),\n        backgroundColor: color({ value: '#050510', label: 'Background' }),\n      }),\n      ...folder('Glow', {\n        glowIntensity: number({ value: 40, min: 5, max: 100, step: 5, label: 'Glow Intensity' }),\n        glowLayers: number({ value: 4, min: 1, max: 8, step: 1, label: 'Glow Layers' }),\n        showParticles: boolean({ value: true, label: 'Show Particles' }),\n      }),\n      ...folder('Animation', {\n        speed: number({ value: 1, min: 0.1, max: 3, step: 0.1, label: 'Speed' }),\n        trailLength: number({ value: 0.15, min: 0.02, max: 0.4, step: 0.01, label: 'Trail Length' }),\n      }),\n    },\n  },\n\n  render({ ctx, width, height, progress, params }) {\n    const {\n      scale,\n      curveExponent,\n      curveAmplitude,\n      lineWidth,\n      backgroundColor,\n      primaryColor,\n      glowColor,\n      glowIntensity,\n      glowLayers,\n      showParticles,\n      speed,\n      trailLength,\n    } = params;\n\n    const adjustedProgress = Math.min((progress * speed), 1);\n    const drawProgress = easeInOutCubic(adjustedProgress);\n\n    // --- Background ---\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, width, height);\n\n    // Subtle radial vignette\n    const vignette = ctx.createRadialGradient(\n      width / 2, height / 2, height * 0.2,\n      width / 2, height / 2, height * 0.9,\n    );\n    vignette.addColorStop(0, 'rgba(0,0,0,0)');\n    vignette.addColorStop(1, 'rgba(0,0,0,0.45)');\n    ctx.fillStyle = vignette;\n    ctx.fillRect(0, 0, width, height);\n\n    // Faint grid lines for depth\n    ctx.save();\n    ctx.globalAlpha = 0.06;\n    ctx.strokeStyle = primaryColor;\n    ctx.lineWidth = 1;\n    const gridSpacing = 60 * scale;\n    for (let x = gridSpacing; x < width; x += gridSpacing) {\n      ctx.beginPath();\n      ctx.moveTo(x, 0);\n      ctx.lineTo(x, height);\n      ctx.stroke();\n    }\n    for (let y = gridSpacing; y < height; y += gridSpacing) {\n      ctx.beginPath();\n      ctx.moveTo(0, y);\n      ctx.lineTo(width, y);\n      ctx.stroke();\n    }\n    ctx.restore();\n\n    // --- Coordinate system ---\n    // The exponential curve goes from (0, 0) at bottom-left of the drawing area\n    // to (1, 1) at top-right, mapped into screen space.\n    const padding = 80 * scale;\n    const plotLeft = padding;\n    const plotRight = width - padding;\n    const plotBottom = height - padding;\n    const plotTop = padding;\n    const plotW = plotRight - plotLeft;\n    const plotH = plotBottom - plotTop;\n\n    // Exponential function: y = ((e^(ex * t) - 1) / (e^ex - 1))  normalized to 0..1\n    const expDenom = Math.exp(curveExponent) - 1;\n    const expFn = (t: number) => (Math.exp(curveExponent * t) - 1) / expDenom;\n\n    // Number of segments for smooth curve\n    const segments = Math.floor(plotW / 2);\n\n    // Helper: map normalized (t, v) to screen\n    const toScreen = (t: number, v: number): [number, number] => {\n      const sx = plotLeft + t * plotW;\n      const sy = plotBottom - v * plotH * curveAmplitude;\n      return [sx, sy];\n    };\n\n    // --- Draw axis lines ---\n    ctx.save();\n    ctx.globalAlpha = 0.15;\n    ctx.strokeStyle = primaryColor;\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(plotLeft, plotBottom);\n    ctx.lineTo(plotRight, plotBottom);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.moveTo(plotLeft, plotBottom);\n    ctx.lineTo(plotLeft, plotTop);\n    ctx.stroke();\n    ctx.restore();\n\n    // --- Build curve path up to drawProgress ---\n    const drawEnd = drawProgress;\n    const totalSegs = Math.max(1, Math.floor(segments * drawEnd));\n\n    // Build the point array\n    const points: [number, number][] = [];\n    for (let i = 0; i <= totalSegs; i++) {\n      const t = (i / segments); // normalised 0..1 along full curve\n      if (t > drawEnd) break;\n      const v = expFn(t);\n      points.push(toScreen(t, v));\n    }\n    // Add exact endpoint at drawEnd\n    const endV = expFn(drawEnd);\n    const endPt = toScreen(drawEnd, endV);\n    if (points.length > 0) {\n      points.push(endPt);\n    }\n\n    if (points.length < 2) {\n      // Not enough to draw yet\n      return;\n    }\n\n    // --- Glow layers (multiple passes with increasing blur) ---\n    for (let layer = glowLayers; layer >= 0; layer--) {\n      ctx.save();\n\n      const isCore = layer === 0;\n      const layerRatio = layer / glowLayers;\n\n      if (isCore) {\n        // Core crisp line\n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = glowIntensity * 0.5;\n        ctx.strokeStyle = primaryColor;\n        ctx.lineWidth = lineWidth * scale;\n        ctx.globalAlpha = 1;\n      } else {\n        // Glow halo\n        ctx.shadowColor = 'transparent';\n        ctx.strokeStyle = glowColor;\n        ctx.lineWidth = (lineWidth * scale) + layer * 4;\n        ctx.globalAlpha = 0.18 * (1 - layerRatio * 0.6);\n        ctx.filter = `blur(${layer * 4}px)`;\n      }\n\n      ctx.lineCap = 'round';\n      ctx.lineJoin = 'round';\n\n      // Draw the curve\n      ctx.beginPath();\n      ctx.moveTo(points[0][0], points[0][1]);\n      for (let i = 1; i < points.length; i++) {\n        ctx.lineTo(points[i][0], points[i][1]);\n      }\n      ctx.stroke();\n\n      ctx.restore();\n    }\n\n    // --- Bright leading dot ---\n    const headRadius = (lineWidth * scale) * 1.6;\n    const [hx, hy] = endPt;\n\n    // Outer glow of head\n    ctx.save();\n    const headGlow = ctx.createRadialGradient(hx, hy, 0, hx, hy, headRadius * 12);\n    headGlow.addColorStop(0, glowColor + 'aa');\n    headGlow.addColorStop(0.3, glowColor + '44');\n    headGlow.addColorStop(1, glowColor + '00');\n    ctx.fillStyle = headGlow;\n    ctx.beginPath();\n    ctx.arc(hx, hy, headRadius * 12, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n\n    // Core dot\n    ctx.save();\n    ctx.shadowColor = glowColor;\n    ctx.shadowBlur = glowIntensity;\n    ctx.fillStyle = '#ffffff';\n    ctx.beginPath();\n    ctx.arc(hx, hy, headRadius, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.restore();\n\n    // --- Trailing fade ---\n    // Fade out the tail end of the drawn curve with a gradient overlay\n    if (drawProgress > trailLength) {\n      const trailStart = Math.max(0, drawProgress - 1); // full curve visible once drawn\n      const fadeLen = trailLength * plotW;\n      const fadeX = plotLeft + trailStart * plotW;\n\n      ctx.save();\n      const fadeGrad = ctx.createLinearGradient(fadeX, 0, fadeX + fadeLen, 0);\n      fadeGrad.addColorStop(0, backgroundColor);\n      fadeGrad.addColorStop(1, backgroundColor + '00');\n      // Only fade very start during reveal\n      if (drawProgress < 0.3) {\n        ctx.fillStyle = fadeGrad;\n        ctx.fillRect(fadeX, 0, fadeLen, height);\n      }\n      ctx.restore();\n    }\n\n    // --- Floating particles along the curve ---\n    if (showParticles && drawProgress > 0.05) {\n      ctx.save();\n      const particleCount = 30;\n      const time = progress * speed * 6;\n\n      for (let i = 0; i < particleCount; i++) {\n        const seed = i * 137.508; // golden angle offset\n        const t = ((seed % 1000) / 1000) * drawEnd;\n        const v = expFn(t);\n        const [px, py] = toScreen(t, v);\n\n        // Float up/down gently\n        const floatOffset = Math.sin(time + seed) * 12 * scale;\n        const driftX = Math.cos(time * 0.7 + seed * 2.3) * 6 * scale;\n\n        const pAlpha = 0.15 + 0.25 * Math.sin(time * 1.3 + seed);\n        const pSize = (1 + Math.sin(time + seed * 0.5)) * 1.5 * scale;\n\n        ctx.globalAlpha = Math.max(0, pAlpha);\n        ctx.fillStyle = primaryColor;\n        ctx.shadowColor = glowColor;\n        ctx.shadowBlur = 8;\n        ctx.beginPath();\n        ctx.arc(px + driftX, py + floatOffset, pSize, 0, Math.PI * 2);\n        ctx.fill();\n      }\n      ctx.restore();\n    }\n\n    // --- \"e^x\" label near the end of the curve ---\n    if (drawProgress > 0.75) {\n      const labelAlpha = easeOutExpo(Math.min(1, (drawProgress - 0.75) / 0.2));\n      ctx.save();\n      ctx.globalAlpha = labelAlpha * 0.7;\n      ctx.fillStyle = primaryColor;\n      ctx.shadowColor = glowColor;\n      ctx.shadowBlur = 20;\n      ctx.font = `${Math.round(22 * scale)}px \"SF Mono\", \"Fira Code\", \"Cascadia Code\", monospace`;\n      ctx.textAlign = 'left';\n      ctx.textBaseline = 'bottom';\n\n      const labelT = 0.82;\n      const labelV = expFn(labelT);\n      const [lx, ly] = toScreen(labelT, labelV);\n      ctx.fillText('eË£', lx + 14 * scale, ly - 10 * scale);\n      ctx.restore();\n    }\n  },\n};\n\nexport default animation;\n\n[END ANIMATION]\n\nI want to remove the e^x text",
  "tags": [
    "glow",
    "curve",
    "exponential",
    "neon",
    "polish",
    "no-label"
  ]
}